// Generated by the protocol buffer compiler.  DO NOT EDIT!
// source: definicion_mensajeria.proto

#ifndef PROTOBUF_definicion_5fmensajeria_2eproto__INCLUDED
#define PROTOBUF_definicion_5fmensajeria_2eproto__INCLUDED

#include <string>

#include <google/protobuf/stubs/common.h>

#if GOOGLE_PROTOBUF_VERSION < 2005000
#error This file was generated by a newer version of protoc which is
#error incompatible with your Protocol Buffer headers.  Please update
#error your headers.
#endif
#if 2005000 < GOOGLE_PROTOBUF_MIN_PROTOC_VERSION
#error This file was generated by an older version of protoc which is
#error incompatible with your Protocol Buffer headers.  Please
#error regenerate this file with a newer version of protoc.
#endif

#include <google/protobuf/generated_message_util.h>
#include <google/protobuf/message.h>
#include <google/protobuf/repeated_field.h>
#include <google/protobuf/extension_set.h>
#include <google/protobuf/generated_enum_reflection.h>
#include <google/protobuf/unknown_field_set.h>
// @@protoc_insertion_point(includes)

namespace Mensajes {

// Internal implementation detail -- do not call these.
void  protobuf_AddDesc_definicion_5fmensajeria_2eproto();
void protobuf_AssignDesc_definicion_5fmensajeria_2eproto();
void protobuf_ShutdownFile_definicion_5fmensajeria_2eproto();

class MessageHeader;
class TypeValue;
class InfoDupla;
class MessageCommand;
class EventInfoDupla;
class MessageEvent;
class MessageData;

enum MessageHeader_MessageType {
  MessageHeader_MessageType_Command = 1,
  MessageHeader_MessageType_Event = 2,
  MessageHeader_MessageType_Data = 3
};
bool MessageHeader_MessageType_IsValid(int value);
const MessageHeader_MessageType MessageHeader_MessageType_MessageType_MIN = MessageHeader_MessageType_Command;
const MessageHeader_MessageType MessageHeader_MessageType_MessageType_MAX = MessageHeader_MessageType_Data;
const int MessageHeader_MessageType_MessageType_ARRAYSIZE = MessageHeader_MessageType_MessageType_MAX + 1;

const ::google::protobuf::EnumDescriptor* MessageHeader_MessageType_descriptor();
inline const ::std::string& MessageHeader_MessageType_Name(MessageHeader_MessageType value) {
  return ::google::protobuf::internal::NameOfEnum(
    MessageHeader_MessageType_descriptor(), value);
}
inline bool MessageHeader_MessageType_Parse(
    const ::std::string& name, MessageHeader_MessageType* value) {
  return ::google::protobuf::internal::ParseNamedEnum<MessageHeader_MessageType>(
    MessageHeader_MessageType_descriptor(), name, value);
}
enum TypeValue_Type {
  TypeValue_Type_stringType = 1,
  TypeValue_Type_int32Type = 2,
  TypeValue_Type_uint32Type = 3,
  TypeValue_Type_floatType = 4,
  TypeValue_Type_doubleType = 5,
  TypeValue_Type_boolType = 6
};
bool TypeValue_Type_IsValid(int value);
const TypeValue_Type TypeValue_Type_Type_MIN = TypeValue_Type_stringType;
const TypeValue_Type TypeValue_Type_Type_MAX = TypeValue_Type_boolType;
const int TypeValue_Type_Type_ARRAYSIZE = TypeValue_Type_Type_MAX + 1;

const ::google::protobuf::EnumDescriptor* TypeValue_Type_descriptor();
inline const ::std::string& TypeValue_Type_Name(TypeValue_Type value) {
  return ::google::protobuf::internal::NameOfEnum(
    TypeValue_Type_descriptor(), value);
}
inline bool TypeValue_Type_Parse(
    const ::std::string& name, TypeValue_Type* value) {
  return ::google::protobuf::internal::ParseNamedEnum<TypeValue_Type>(
    TypeValue_Type_descriptor(), name, value);
}
enum MessageCommand_ECmdState {
  MessageCommand_ECmdState_SEND = 1,
  MessageCommand_ECmdState_CMD_ACK = 2,
  MessageCommand_ECmdState_CMD_NOT_ACK = 3,
  MessageCommand_ECmdState_CMD_EXECUTED = 4,
  MessageCommand_ECmdState_CMD_EXECUTING = 5
};
bool MessageCommand_ECmdState_IsValid(int value);
const MessageCommand_ECmdState MessageCommand_ECmdState_ECmdState_MIN = MessageCommand_ECmdState_SEND;
const MessageCommand_ECmdState MessageCommand_ECmdState_ECmdState_MAX = MessageCommand_ECmdState_CMD_EXECUTING;
const int MessageCommand_ECmdState_ECmdState_ARRAYSIZE = MessageCommand_ECmdState_ECmdState_MAX + 1;

const ::google::protobuf::EnumDescriptor* MessageCommand_ECmdState_descriptor();
inline const ::std::string& MessageCommand_ECmdState_Name(MessageCommand_ECmdState value) {
  return ::google::protobuf::internal::NameOfEnum(
    MessageCommand_ECmdState_descriptor(), value);
}
inline bool MessageCommand_ECmdState_Parse(
    const ::std::string& name, MessageCommand_ECmdState* value) {
  return ::google::protobuf::internal::ParseNamedEnum<MessageCommand_ECmdState>(
    MessageCommand_ECmdState_descriptor(), name, value);
}
// ===================================================================

class MessageHeader : public ::google::protobuf::Message {
 public:
  MessageHeader();
  virtual ~MessageHeader();

  MessageHeader(const MessageHeader& from);

  inline MessageHeader& operator=(const MessageHeader& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const MessageHeader& default_instance();

  void Swap(MessageHeader* other);

  // implements Message ----------------------------------------------

  MessageHeader* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const MessageHeader& from);
  void MergeFrom(const MessageHeader& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:

  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  typedef MessageHeader_MessageType MessageType;
  static const MessageType Command = MessageHeader_MessageType_Command;
  static const MessageType Event = MessageHeader_MessageType_Event;
  static const MessageType Data = MessageHeader_MessageType_Data;
  static inline bool MessageType_IsValid(int value) {
    return MessageHeader_MessageType_IsValid(value);
  }
  static const MessageType MessageType_MIN =
    MessageHeader_MessageType_MessageType_MIN;
  static const MessageType MessageType_MAX =
    MessageHeader_MessageType_MessageType_MAX;
  static const int MessageType_ARRAYSIZE =
    MessageHeader_MessageType_MessageType_ARRAYSIZE;
  static inline const ::google::protobuf::EnumDescriptor*
  MessageType_descriptor() {
    return MessageHeader_MessageType_descriptor();
  }
  static inline const ::std::string& MessageType_Name(MessageType value) {
    return MessageHeader_MessageType_Name(value);
  }
  static inline bool MessageType_Parse(const ::std::string& name,
      MessageType* value) {
    return MessageHeader_MessageType_Parse(name, value);
  }

  // accessors -------------------------------------------------------

  // required uint32 IDCompSource = 1;
  inline bool has_idcompsource() const;
  inline void clear_idcompsource();
  static const int kIDCompSourceFieldNumber = 1;
  inline ::google::protobuf::uint32 idcompsource() const;
  inline void set_idcompsource(::google::protobuf::uint32 value);

  // required uint32 IDMessage = 2;
  inline bool has_idmessage() const;
  inline void clear_idmessage();
  static const int kIDMessageFieldNumber = 2;
  inline ::google::protobuf::uint32 idmessage() const;
  inline void set_idmessage(::google::protobuf::uint32 value);

  // required bool ReturnAck = 3;
  inline bool has_returnack() const;
  inline void clear_returnack();
  static const int kReturnAckFieldNumber = 3;
  inline bool returnack() const;
  inline void set_returnack(bool value);

  // required .Mensajes.MessageHeader.MessageType MsgType = 4;
  inline bool has_msgtype() const;
  inline void clear_msgtype();
  static const int kMsgTypeFieldNumber = 4;
  inline ::Mensajes::MessageHeader_MessageType msgtype() const;
  inline void set_msgtype(::Mensajes::MessageHeader_MessageType value);

  // required uint32 IDCompTarget = 5;
  inline bool has_idcomptarget() const;
  inline void clear_idcomptarget();
  static const int kIDCompTargetFieldNumber = 5;
  inline ::google::protobuf::uint32 idcomptarget() const;
  inline void set_idcomptarget(::google::protobuf::uint32 value);

  // required double timestamp = 6;
  inline bool has_timestamp() const;
  inline void clear_timestamp();
  static const int kTimestampFieldNumber = 6;
  inline double timestamp() const;
  inline void set_timestamp(double value);

  // @@protoc_insertion_point(class_scope:Mensajes.MessageHeader)
 private:
  inline void set_has_idcompsource();
  inline void clear_has_idcompsource();
  inline void set_has_idmessage();
  inline void clear_has_idmessage();
  inline void set_has_returnack();
  inline void clear_has_returnack();
  inline void set_has_msgtype();
  inline void clear_has_msgtype();
  inline void set_has_idcomptarget();
  inline void clear_has_idcomptarget();
  inline void set_has_timestamp();
  inline void clear_has_timestamp();

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  ::google::protobuf::uint32 idcompsource_;
  ::google::protobuf::uint32 idmessage_;
  bool returnack_;
  int msgtype_;
  double timestamp_;
  ::google::protobuf::uint32 idcomptarget_;

  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(6 + 31) / 32];

  friend void  protobuf_AddDesc_definicion_5fmensajeria_2eproto();
  friend void protobuf_AssignDesc_definicion_5fmensajeria_2eproto();
  friend void protobuf_ShutdownFile_definicion_5fmensajeria_2eproto();

  void InitAsDefaultInstance();
  static MessageHeader* default_instance_;
};
// -------------------------------------------------------------------

class TypeValue : public ::google::protobuf::Message {
 public:
  TypeValue();
  virtual ~TypeValue();

  TypeValue(const TypeValue& from);

  inline TypeValue& operator=(const TypeValue& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const TypeValue& default_instance();

  void Swap(TypeValue* other);

  // implements Message ----------------------------------------------

  TypeValue* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const TypeValue& from);
  void MergeFrom(const TypeValue& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:

  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  typedef TypeValue_Type Type;
  static const Type stringType = TypeValue_Type_stringType;
  static const Type int32Type = TypeValue_Type_int32Type;
  static const Type uint32Type = TypeValue_Type_uint32Type;
  static const Type floatType = TypeValue_Type_floatType;
  static const Type doubleType = TypeValue_Type_doubleType;
  static const Type boolType = TypeValue_Type_boolType;
  static inline bool Type_IsValid(int value) {
    return TypeValue_Type_IsValid(value);
  }
  static const Type Type_MIN =
    TypeValue_Type_Type_MIN;
  static const Type Type_MAX =
    TypeValue_Type_Type_MAX;
  static const int Type_ARRAYSIZE =
    TypeValue_Type_Type_ARRAYSIZE;
  static inline const ::google::protobuf::EnumDescriptor*
  Type_descriptor() {
    return TypeValue_Type_descriptor();
  }
  static inline const ::std::string& Type_Name(Type value) {
    return TypeValue_Type_Name(value);
  }
  static inline bool Type_Parse(const ::std::string& name,
      Type* value) {
    return TypeValue_Type_Parse(name, value);
  }

  // accessors -------------------------------------------------------

  // required .Mensajes.TypeValue.Type typArg = 1;
  inline bool has_typarg() const;
  inline void clear_typarg();
  static const int kTypArgFieldNumber = 1;
  inline ::Mensajes::TypeValue_Type typarg() const;
  inline void set_typarg(::Mensajes::TypeValue_Type value);

  // optional string strArg = 2;
  inline bool has_strarg() const;
  inline void clear_strarg();
  static const int kStrArgFieldNumber = 2;
  inline const ::std::string& strarg() const;
  inline void set_strarg(const ::std::string& value);
  inline void set_strarg(const char* value);
  inline void set_strarg(const char* value, size_t size);
  inline ::std::string* mutable_strarg();
  inline ::std::string* release_strarg();
  inline void set_allocated_strarg(::std::string* strarg);

  // optional int32 int32Arg = 3;
  inline bool has_int32arg() const;
  inline void clear_int32arg();
  static const int kInt32ArgFieldNumber = 3;
  inline ::google::protobuf::int32 int32arg() const;
  inline void set_int32arg(::google::protobuf::int32 value);

  // optional uint32 uint32Arg = 4;
  inline bool has_uint32arg() const;
  inline void clear_uint32arg();
  static const int kUint32ArgFieldNumber = 4;
  inline ::google::protobuf::uint32 uint32arg() const;
  inline void set_uint32arg(::google::protobuf::uint32 value);

  // optional float floatArg = 5;
  inline bool has_floatarg() const;
  inline void clear_floatarg();
  static const int kFloatArgFieldNumber = 5;
  inline float floatarg() const;
  inline void set_floatarg(float value);

  // optional double doubleArg = 6;
  inline bool has_doublearg() const;
  inline void clear_doublearg();
  static const int kDoubleArgFieldNumber = 6;
  inline double doublearg() const;
  inline void set_doublearg(double value);

  // optional bool boolArg = 7;
  inline bool has_boolarg() const;
  inline void clear_boolarg();
  static const int kBoolArgFieldNumber = 7;
  inline bool boolarg() const;
  inline void set_boolarg(bool value);

  // @@protoc_insertion_point(class_scope:Mensajes.TypeValue)
 private:
  inline void set_has_typarg();
  inline void clear_has_typarg();
  inline void set_has_strarg();
  inline void clear_has_strarg();
  inline void set_has_int32arg();
  inline void clear_has_int32arg();
  inline void set_has_uint32arg();
  inline void clear_has_uint32arg();
  inline void set_has_floatarg();
  inline void clear_has_floatarg();
  inline void set_has_doublearg();
  inline void clear_has_doublearg();
  inline void set_has_boolarg();
  inline void clear_has_boolarg();

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  ::std::string* strarg_;
  int typarg_;
  ::google::protobuf::int32 int32arg_;
  ::google::protobuf::uint32 uint32arg_;
  float floatarg_;
  double doublearg_;
  bool boolarg_;

  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(7 + 31) / 32];

  friend void  protobuf_AddDesc_definicion_5fmensajeria_2eproto();
  friend void protobuf_AssignDesc_definicion_5fmensajeria_2eproto();
  friend void protobuf_ShutdownFile_definicion_5fmensajeria_2eproto();

  void InitAsDefaultInstance();
  static TypeValue* default_instance_;
};
// -------------------------------------------------------------------

class InfoDupla : public ::google::protobuf::Message {
 public:
  InfoDupla();
  virtual ~InfoDupla();

  InfoDupla(const InfoDupla& from);

  inline InfoDupla& operator=(const InfoDupla& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const InfoDupla& default_instance();

  void Swap(InfoDupla* other);

  // implements Message ----------------------------------------------

  InfoDupla* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const InfoDupla& from);
  void MergeFrom(const InfoDupla& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:

  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // required uint32 IDArg = 2;
  inline bool has_idarg() const;
  inline void clear_idarg();
  static const int kIDArgFieldNumber = 2;
  inline ::google::protobuf::uint32 idarg() const;
  inline void set_idarg(::google::protobuf::uint32 value);

  // required .Mensajes.TypeValue ArgValue = 1;
  inline bool has_argvalue() const;
  inline void clear_argvalue();
  static const int kArgValueFieldNumber = 1;
  inline const ::Mensajes::TypeValue& argvalue() const;
  inline ::Mensajes::TypeValue* mutable_argvalue();
  inline ::Mensajes::TypeValue* release_argvalue();
  inline void set_allocated_argvalue(::Mensajes::TypeValue* argvalue);

  // @@protoc_insertion_point(class_scope:Mensajes.InfoDupla)
 private:
  inline void set_has_idarg();
  inline void clear_has_idarg();
  inline void set_has_argvalue();
  inline void clear_has_argvalue();

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  ::Mensajes::TypeValue* argvalue_;
  ::google::protobuf::uint32 idarg_;

  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(2 + 31) / 32];

  friend void  protobuf_AddDesc_definicion_5fmensajeria_2eproto();
  friend void protobuf_AssignDesc_definicion_5fmensajeria_2eproto();
  friend void protobuf_ShutdownFile_definicion_5fmensajeria_2eproto();

  void InitAsDefaultInstance();
  static InfoDupla* default_instance_;
};
// -------------------------------------------------------------------

class MessageCommand : public ::google::protobuf::Message {
 public:
  MessageCommand();
  virtual ~MessageCommand();

  MessageCommand(const MessageCommand& from);

  inline MessageCommand& operator=(const MessageCommand& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const MessageCommand& default_instance();

  void Swap(MessageCommand* other);

  // implements Message ----------------------------------------------

  MessageCommand* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const MessageCommand& from);
  void MergeFrom(const MessageCommand& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:

  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  typedef MessageCommand_ECmdState ECmdState;
  static const ECmdState SEND = MessageCommand_ECmdState_SEND;
  static const ECmdState CMD_ACK = MessageCommand_ECmdState_CMD_ACK;
  static const ECmdState CMD_NOT_ACK = MessageCommand_ECmdState_CMD_NOT_ACK;
  static const ECmdState CMD_EXECUTED = MessageCommand_ECmdState_CMD_EXECUTED;
  static const ECmdState CMD_EXECUTING = MessageCommand_ECmdState_CMD_EXECUTING;
  static inline bool ECmdState_IsValid(int value) {
    return MessageCommand_ECmdState_IsValid(value);
  }
  static const ECmdState ECmdState_MIN =
    MessageCommand_ECmdState_ECmdState_MIN;
  static const ECmdState ECmdState_MAX =
    MessageCommand_ECmdState_ECmdState_MAX;
  static const int ECmdState_ARRAYSIZE =
    MessageCommand_ECmdState_ECmdState_ARRAYSIZE;
  static inline const ::google::protobuf::EnumDescriptor*
  ECmdState_descriptor() {
    return MessageCommand_ECmdState_descriptor();
  }
  static inline const ::std::string& ECmdState_Name(ECmdState value) {
    return MessageCommand_ECmdState_Name(value);
  }
  static inline bool ECmdState_Parse(const ::std::string& name,
      ECmdState* value) {
    return MessageCommand_ECmdState_Parse(name, value);
  }

  // accessors -------------------------------------------------------

  // required .Mensajes.MessageHeader header = 4;
  inline bool has_header() const;
  inline void clear_header();
  static const int kHeaderFieldNumber = 4;
  inline const ::Mensajes::MessageHeader& header() const;
  inline ::Mensajes::MessageHeader* mutable_header();
  inline ::Mensajes::MessageHeader* release_header();
  inline void set_allocated_header(::Mensajes::MessageHeader* header);

  // required uint32 IDCommand = 1;
  inline bool has_idcommand() const;
  inline void clear_idcommand();
  static const int kIDCommandFieldNumber = 1;
  inline ::google::protobuf::uint32 idcommand() const;
  inline void set_idcommand(::google::protobuf::uint32 value);

  // required .Mensajes.MessageCommand.ECmdState CmdState = 2;
  inline bool has_cmdstate() const;
  inline void clear_cmdstate();
  static const int kCmdStateFieldNumber = 2;
  inline ::Mensajes::MessageCommand_ECmdState cmdstate() const;
  inline void set_cmdstate(::Mensajes::MessageCommand_ECmdState value);

  // repeated .Mensajes.InfoDupla argument = 3;
  inline int argument_size() const;
  inline void clear_argument();
  static const int kArgumentFieldNumber = 3;
  inline const ::Mensajes::InfoDupla& argument(int index) const;
  inline ::Mensajes::InfoDupla* mutable_argument(int index);
  inline ::Mensajes::InfoDupla* add_argument();
  inline const ::google::protobuf::RepeatedPtrField< ::Mensajes::InfoDupla >&
      argument() const;
  inline ::google::protobuf::RepeatedPtrField< ::Mensajes::InfoDupla >*
      mutable_argument();

  // @@protoc_insertion_point(class_scope:Mensajes.MessageCommand)
 private:
  inline void set_has_header();
  inline void clear_has_header();
  inline void set_has_idcommand();
  inline void clear_has_idcommand();
  inline void set_has_cmdstate();
  inline void clear_has_cmdstate();

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  ::Mensajes::MessageHeader* header_;
  ::google::protobuf::uint32 idcommand_;
  int cmdstate_;
  ::google::protobuf::RepeatedPtrField< ::Mensajes::InfoDupla > argument_;

  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(4 + 31) / 32];

  friend void  protobuf_AddDesc_definicion_5fmensajeria_2eproto();
  friend void protobuf_AssignDesc_definicion_5fmensajeria_2eproto();
  friend void protobuf_ShutdownFile_definicion_5fmensajeria_2eproto();

  void InitAsDefaultInstance();
  static MessageCommand* default_instance_;
};
// -------------------------------------------------------------------

class EventInfoDupla : public ::google::protobuf::Message {
 public:
  EventInfoDupla();
  virtual ~EventInfoDupla();

  EventInfoDupla(const EventInfoDupla& from);

  inline EventInfoDupla& operator=(const EventInfoDupla& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const EventInfoDupla& default_instance();

  void Swap(EventInfoDupla* other);

  // implements Message ----------------------------------------------

  EventInfoDupla* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const EventInfoDupla& from);
  void MergeFrom(const EventInfoDupla& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:

  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // required uint32 idComponente = 1;
  inline bool has_idcomponente() const;
  inline void clear_idcomponente();
  static const int kIdComponenteFieldNumber = 1;
  inline ::google::protobuf::uint32 idcomponente() const;
  inline void set_idcomponente(::google::protobuf::uint32 value);

  // required uint32 idEvento = 2;
  inline bool has_idevento() const;
  inline void clear_idevento();
  static const int kIdEventoFieldNumber = 2;
  inline ::google::protobuf::uint32 idevento() const;
  inline void set_idevento(::google::protobuf::uint32 value);

  // @@protoc_insertion_point(class_scope:Mensajes.EventInfoDupla)
 private:
  inline void set_has_idcomponente();
  inline void clear_has_idcomponente();
  inline void set_has_idevento();
  inline void clear_has_idevento();

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  ::google::protobuf::uint32 idcomponente_;
  ::google::protobuf::uint32 idevento_;

  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(2 + 31) / 32];

  friend void  protobuf_AddDesc_definicion_5fmensajeria_2eproto();
  friend void protobuf_AssignDesc_definicion_5fmensajeria_2eproto();
  friend void protobuf_ShutdownFile_definicion_5fmensajeria_2eproto();

  void InitAsDefaultInstance();
  static EventInfoDupla* default_instance_;
};
// -------------------------------------------------------------------

class MessageEvent : public ::google::protobuf::Message {
 public:
  MessageEvent();
  virtual ~MessageEvent();

  MessageEvent(const MessageEvent& from);

  inline MessageEvent& operator=(const MessageEvent& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const MessageEvent& default_instance();

  void Swap(MessageEvent* other);

  // implements Message ----------------------------------------------

  MessageEvent* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const MessageEvent& from);
  void MergeFrom(const MessageEvent& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:

  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // required .Mensajes.MessageHeader header = 2;
  inline bool has_header() const;
  inline void clear_header();
  static const int kHeaderFieldNumber = 2;
  inline const ::Mensajes::MessageHeader& header() const;
  inline ::Mensajes::MessageHeader* mutable_header();
  inline ::Mensajes::MessageHeader* release_header();
  inline void set_allocated_header(::Mensajes::MessageHeader* header);

  // repeated .Mensajes.EventInfoDupla events = 1;
  inline int events_size() const;
  inline void clear_events();
  static const int kEventsFieldNumber = 1;
  inline const ::Mensajes::EventInfoDupla& events(int index) const;
  inline ::Mensajes::EventInfoDupla* mutable_events(int index);
  inline ::Mensajes::EventInfoDupla* add_events();
  inline const ::google::protobuf::RepeatedPtrField< ::Mensajes::EventInfoDupla >&
      events() const;
  inline ::google::protobuf::RepeatedPtrField< ::Mensajes::EventInfoDupla >*
      mutable_events();

  // required uint32 eventType = 3;
  inline bool has_eventtype() const;
  inline void clear_eventtype();
  static const int kEventTypeFieldNumber = 3;
  inline ::google::protobuf::uint32 eventtype() const;
  inline void set_eventtype(::google::protobuf::uint32 value);

  // @@protoc_insertion_point(class_scope:Mensajes.MessageEvent)
 private:
  inline void set_has_header();
  inline void clear_has_header();
  inline void set_has_eventtype();
  inline void clear_has_eventtype();

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  ::Mensajes::MessageHeader* header_;
  ::google::protobuf::RepeatedPtrField< ::Mensajes::EventInfoDupla > events_;
  ::google::protobuf::uint32 eventtype_;

  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(3 + 31) / 32];

  friend void  protobuf_AddDesc_definicion_5fmensajeria_2eproto();
  friend void protobuf_AssignDesc_definicion_5fmensajeria_2eproto();
  friend void protobuf_ShutdownFile_definicion_5fmensajeria_2eproto();

  void InitAsDefaultInstance();
  static MessageEvent* default_instance_;
};
// -------------------------------------------------------------------

class MessageData : public ::google::protobuf::Message {
 public:
  MessageData();
  virtual ~MessageData();

  MessageData(const MessageData& from);

  inline MessageData& operator=(const MessageData& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const MessageData& default_instance();

  void Swap(MessageData* other);

  // implements Message ----------------------------------------------

  MessageData* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const MessageData& from);
  void MergeFrom(const MessageData& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:

  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // required .Mensajes.MessageHeader header = 2;
  inline bool has_header() const;
  inline void clear_header();
  static const int kHeaderFieldNumber = 2;
  inline const ::Mensajes::MessageHeader& header() const;
  inline ::Mensajes::MessageHeader* mutable_header();
  inline ::Mensajes::MessageHeader* release_header();
  inline void set_allocated_header(::Mensajes::MessageHeader* header);

  // required uint32 IDData = 3;
  inline bool has_iddata() const;
  inline void clear_iddata();
  static const int kIDDataFieldNumber = 3;
  inline ::google::protobuf::uint32 iddata() const;
  inline void set_iddata(::google::protobuf::uint32 value);

  // repeated .Mensajes.InfoDupla metadatos = 1;
  inline int metadatos_size() const;
  inline void clear_metadatos();
  static const int kMetadatosFieldNumber = 1;
  inline const ::Mensajes::InfoDupla& metadatos(int index) const;
  inline ::Mensajes::InfoDupla* mutable_metadatos(int index);
  inline ::Mensajes::InfoDupla* add_metadatos();
  inline const ::google::protobuf::RepeatedPtrField< ::Mensajes::InfoDupla >&
      metadatos() const;
  inline ::google::protobuf::RepeatedPtrField< ::Mensajes::InfoDupla >*
      mutable_metadatos();

  // @@protoc_insertion_point(class_scope:Mensajes.MessageData)
 private:
  inline void set_has_header();
  inline void clear_has_header();
  inline void set_has_iddata();
  inline void clear_has_iddata();

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  ::Mensajes::MessageHeader* header_;
  ::google::protobuf::RepeatedPtrField< ::Mensajes::InfoDupla > metadatos_;
  ::google::protobuf::uint32 iddata_;

  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(3 + 31) / 32];

  friend void  protobuf_AddDesc_definicion_5fmensajeria_2eproto();
  friend void protobuf_AssignDesc_definicion_5fmensajeria_2eproto();
  friend void protobuf_ShutdownFile_definicion_5fmensajeria_2eproto();

  void InitAsDefaultInstance();
  static MessageData* default_instance_;
};
// ===================================================================


// ===================================================================

// MessageHeader

// required uint32 IDCompSource = 1;
inline bool MessageHeader::has_idcompsource() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void MessageHeader::set_has_idcompsource() {
  _has_bits_[0] |= 0x00000001u;
}
inline void MessageHeader::clear_has_idcompsource() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void MessageHeader::clear_idcompsource() {
  idcompsource_ = 0u;
  clear_has_idcompsource();
}
inline ::google::protobuf::uint32 MessageHeader::idcompsource() const {
  return idcompsource_;
}
inline void MessageHeader::set_idcompsource(::google::protobuf::uint32 value) {
  set_has_idcompsource();
  idcompsource_ = value;
}

// required uint32 IDMessage = 2;
inline bool MessageHeader::has_idmessage() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void MessageHeader::set_has_idmessage() {
  _has_bits_[0] |= 0x00000002u;
}
inline void MessageHeader::clear_has_idmessage() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void MessageHeader::clear_idmessage() {
  idmessage_ = 0u;
  clear_has_idmessage();
}
inline ::google::protobuf::uint32 MessageHeader::idmessage() const {
  return idmessage_;
}
inline void MessageHeader::set_idmessage(::google::protobuf::uint32 value) {
  set_has_idmessage();
  idmessage_ = value;
}

// required bool ReturnAck = 3;
inline bool MessageHeader::has_returnack() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void MessageHeader::set_has_returnack() {
  _has_bits_[0] |= 0x00000004u;
}
inline void MessageHeader::clear_has_returnack() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void MessageHeader::clear_returnack() {
  returnack_ = false;
  clear_has_returnack();
}
inline bool MessageHeader::returnack() const {
  return returnack_;
}
inline void MessageHeader::set_returnack(bool value) {
  set_has_returnack();
  returnack_ = value;
}

// required .Mensajes.MessageHeader.MessageType MsgType = 4;
inline bool MessageHeader::has_msgtype() const {
  return (_has_bits_[0] & 0x00000008u) != 0;
}
inline void MessageHeader::set_has_msgtype() {
  _has_bits_[0] |= 0x00000008u;
}
inline void MessageHeader::clear_has_msgtype() {
  _has_bits_[0] &= ~0x00000008u;
}
inline void MessageHeader::clear_msgtype() {
  msgtype_ = 1;
  clear_has_msgtype();
}
inline ::Mensajes::MessageHeader_MessageType MessageHeader::msgtype() const {
  return static_cast< ::Mensajes::MessageHeader_MessageType >(msgtype_);
}
inline void MessageHeader::set_msgtype(::Mensajes::MessageHeader_MessageType value) {
  assert(::Mensajes::MessageHeader_MessageType_IsValid(value));
  set_has_msgtype();
  msgtype_ = value;
}

// required uint32 IDCompTarget = 5;
inline bool MessageHeader::has_idcomptarget() const {
  return (_has_bits_[0] & 0x00000010u) != 0;
}
inline void MessageHeader::set_has_idcomptarget() {
  _has_bits_[0] |= 0x00000010u;
}
inline void MessageHeader::clear_has_idcomptarget() {
  _has_bits_[0] &= ~0x00000010u;
}
inline void MessageHeader::clear_idcomptarget() {
  idcomptarget_ = 0u;
  clear_has_idcomptarget();
}
inline ::google::protobuf::uint32 MessageHeader::idcomptarget() const {
  return idcomptarget_;
}
inline void MessageHeader::set_idcomptarget(::google::protobuf::uint32 value) {
  set_has_idcomptarget();
  idcomptarget_ = value;
}

// required double timestamp = 6;
inline bool MessageHeader::has_timestamp() const {
  return (_has_bits_[0] & 0x00000020u) != 0;
}
inline void MessageHeader::set_has_timestamp() {
  _has_bits_[0] |= 0x00000020u;
}
inline void MessageHeader::clear_has_timestamp() {
  _has_bits_[0] &= ~0x00000020u;
}
inline void MessageHeader::clear_timestamp() {
  timestamp_ = 0;
  clear_has_timestamp();
}
inline double MessageHeader::timestamp() const {
  return timestamp_;
}
inline void MessageHeader::set_timestamp(double value) {
  set_has_timestamp();
  timestamp_ = value;
}

// -------------------------------------------------------------------

// TypeValue

// required .Mensajes.TypeValue.Type typArg = 1;
inline bool TypeValue::has_typarg() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void TypeValue::set_has_typarg() {
  _has_bits_[0] |= 0x00000001u;
}
inline void TypeValue::clear_has_typarg() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void TypeValue::clear_typarg() {
  typarg_ = 1;
  clear_has_typarg();
}
inline ::Mensajes::TypeValue_Type TypeValue::typarg() const {
  return static_cast< ::Mensajes::TypeValue_Type >(typarg_);
}
inline void TypeValue::set_typarg(::Mensajes::TypeValue_Type value) {
  assert(::Mensajes::TypeValue_Type_IsValid(value));
  set_has_typarg();
  typarg_ = value;
}

// optional string strArg = 2;
inline bool TypeValue::has_strarg() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void TypeValue::set_has_strarg() {
  _has_bits_[0] |= 0x00000002u;
}
inline void TypeValue::clear_has_strarg() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void TypeValue::clear_strarg() {
  if (strarg_ != &::google::protobuf::internal::kEmptyString) {
    strarg_->clear();
  }
  clear_has_strarg();
}
inline const ::std::string& TypeValue::strarg() const {
  return *strarg_;
}
inline void TypeValue::set_strarg(const ::std::string& value) {
  set_has_strarg();
  if (strarg_ == &::google::protobuf::internal::kEmptyString) {
    strarg_ = new ::std::string;
  }
  strarg_->assign(value);
}
inline void TypeValue::set_strarg(const char* value) {
  set_has_strarg();
  if (strarg_ == &::google::protobuf::internal::kEmptyString) {
    strarg_ = new ::std::string;
  }
  strarg_->assign(value);
}
inline void TypeValue::set_strarg(const char* value, size_t size) {
  set_has_strarg();
  if (strarg_ == &::google::protobuf::internal::kEmptyString) {
    strarg_ = new ::std::string;
  }
  strarg_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* TypeValue::mutable_strarg() {
  set_has_strarg();
  if (strarg_ == &::google::protobuf::internal::kEmptyString) {
    strarg_ = new ::std::string;
  }
  return strarg_;
}
inline ::std::string* TypeValue::release_strarg() {
  clear_has_strarg();
  if (strarg_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = strarg_;
    strarg_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}
inline void TypeValue::set_allocated_strarg(::std::string* strarg) {
  if (strarg_ != &::google::protobuf::internal::kEmptyString) {
    delete strarg_;
  }
  if (strarg) {
    set_has_strarg();
    strarg_ = strarg;
  } else {
    clear_has_strarg();
    strarg_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  }
}

// optional int32 int32Arg = 3;
inline bool TypeValue::has_int32arg() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void TypeValue::set_has_int32arg() {
  _has_bits_[0] |= 0x00000004u;
}
inline void TypeValue::clear_has_int32arg() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void TypeValue::clear_int32arg() {
  int32arg_ = 0;
  clear_has_int32arg();
}
inline ::google::protobuf::int32 TypeValue::int32arg() const {
  return int32arg_;
}
inline void TypeValue::set_int32arg(::google::protobuf::int32 value) {
  set_has_int32arg();
  int32arg_ = value;
}

// optional uint32 uint32Arg = 4;
inline bool TypeValue::has_uint32arg() const {
  return (_has_bits_[0] & 0x00000008u) != 0;
}
inline void TypeValue::set_has_uint32arg() {
  _has_bits_[0] |= 0x00000008u;
}
inline void TypeValue::clear_has_uint32arg() {
  _has_bits_[0] &= ~0x00000008u;
}
inline void TypeValue::clear_uint32arg() {
  uint32arg_ = 0u;
  clear_has_uint32arg();
}
inline ::google::protobuf::uint32 TypeValue::uint32arg() const {
  return uint32arg_;
}
inline void TypeValue::set_uint32arg(::google::protobuf::uint32 value) {
  set_has_uint32arg();
  uint32arg_ = value;
}

// optional float floatArg = 5;
inline bool TypeValue::has_floatarg() const {
  return (_has_bits_[0] & 0x00000010u) != 0;
}
inline void TypeValue::set_has_floatarg() {
  _has_bits_[0] |= 0x00000010u;
}
inline void TypeValue::clear_has_floatarg() {
  _has_bits_[0] &= ~0x00000010u;
}
inline void TypeValue::clear_floatarg() {
  floatarg_ = 0;
  clear_has_floatarg();
}
inline float TypeValue::floatarg() const {
  return floatarg_;
}
inline void TypeValue::set_floatarg(float value) {
  set_has_floatarg();
  floatarg_ = value;
}

// optional double doubleArg = 6;
inline bool TypeValue::has_doublearg() const {
  return (_has_bits_[0] & 0x00000020u) != 0;
}
inline void TypeValue::set_has_doublearg() {
  _has_bits_[0] |= 0x00000020u;
}
inline void TypeValue::clear_has_doublearg() {
  _has_bits_[0] &= ~0x00000020u;
}
inline void TypeValue::clear_doublearg() {
  doublearg_ = 0;
  clear_has_doublearg();
}
inline double TypeValue::doublearg() const {
  return doublearg_;
}
inline void TypeValue::set_doublearg(double value) {
  set_has_doublearg();
  doublearg_ = value;
}

// optional bool boolArg = 7;
inline bool TypeValue::has_boolarg() const {
  return (_has_bits_[0] & 0x00000040u) != 0;
}
inline void TypeValue::set_has_boolarg() {
  _has_bits_[0] |= 0x00000040u;
}
inline void TypeValue::clear_has_boolarg() {
  _has_bits_[0] &= ~0x00000040u;
}
inline void TypeValue::clear_boolarg() {
  boolarg_ = false;
  clear_has_boolarg();
}
inline bool TypeValue::boolarg() const {
  return boolarg_;
}
inline void TypeValue::set_boolarg(bool value) {
  set_has_boolarg();
  boolarg_ = value;
}

// -------------------------------------------------------------------

// InfoDupla

// required uint32 IDArg = 2;
inline bool InfoDupla::has_idarg() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void InfoDupla::set_has_idarg() {
  _has_bits_[0] |= 0x00000001u;
}
inline void InfoDupla::clear_has_idarg() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void InfoDupla::clear_idarg() {
  idarg_ = 0u;
  clear_has_idarg();
}
inline ::google::protobuf::uint32 InfoDupla::idarg() const {
  return idarg_;
}
inline void InfoDupla::set_idarg(::google::protobuf::uint32 value) {
  set_has_idarg();
  idarg_ = value;
}

// required .Mensajes.TypeValue ArgValue = 1;
inline bool InfoDupla::has_argvalue() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void InfoDupla::set_has_argvalue() {
  _has_bits_[0] |= 0x00000002u;
}
inline void InfoDupla::clear_has_argvalue() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void InfoDupla::clear_argvalue() {
  if (argvalue_ != NULL) argvalue_->::Mensajes::TypeValue::Clear();
  clear_has_argvalue();
}
inline const ::Mensajes::TypeValue& InfoDupla::argvalue() const {
  return argvalue_ != NULL ? *argvalue_ : *default_instance_->argvalue_;
}
inline ::Mensajes::TypeValue* InfoDupla::mutable_argvalue() {
  set_has_argvalue();
  if (argvalue_ == NULL) argvalue_ = new ::Mensajes::TypeValue;
  return argvalue_;
}
inline ::Mensajes::TypeValue* InfoDupla::release_argvalue() {
  clear_has_argvalue();
  ::Mensajes::TypeValue* temp = argvalue_;
  argvalue_ = NULL;
  return temp;
}
inline void InfoDupla::set_allocated_argvalue(::Mensajes::TypeValue* argvalue) {
  delete argvalue_;
  argvalue_ = argvalue;
  if (argvalue) {
    set_has_argvalue();
  } else {
    clear_has_argvalue();
  }
}

// -------------------------------------------------------------------

// MessageCommand

// required .Mensajes.MessageHeader header = 4;
inline bool MessageCommand::has_header() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void MessageCommand::set_has_header() {
  _has_bits_[0] |= 0x00000001u;
}
inline void MessageCommand::clear_has_header() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void MessageCommand::clear_header() {
  if (header_ != NULL) header_->::Mensajes::MessageHeader::Clear();
  clear_has_header();
}
inline const ::Mensajes::MessageHeader& MessageCommand::header() const {
  return header_ != NULL ? *header_ : *default_instance_->header_;
}
inline ::Mensajes::MessageHeader* MessageCommand::mutable_header() {
  set_has_header();
  if (header_ == NULL) header_ = new ::Mensajes::MessageHeader;
  return header_;
}
inline ::Mensajes::MessageHeader* MessageCommand::release_header() {
  clear_has_header();
  ::Mensajes::MessageHeader* temp = header_;
  header_ = NULL;
  return temp;
}
inline void MessageCommand::set_allocated_header(::Mensajes::MessageHeader* header) {
  delete header_;
  header_ = header;
  if (header) {
    set_has_header();
  } else {
    clear_has_header();
  }
}

// required uint32 IDCommand = 1;
inline bool MessageCommand::has_idcommand() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void MessageCommand::set_has_idcommand() {
  _has_bits_[0] |= 0x00000002u;
}
inline void MessageCommand::clear_has_idcommand() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void MessageCommand::clear_idcommand() {
  idcommand_ = 0u;
  clear_has_idcommand();
}
inline ::google::protobuf::uint32 MessageCommand::idcommand() const {
  return idcommand_;
}
inline void MessageCommand::set_idcommand(::google::protobuf::uint32 value) {
  set_has_idcommand();
  idcommand_ = value;
}

// required .Mensajes.MessageCommand.ECmdState CmdState = 2;
inline bool MessageCommand::has_cmdstate() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void MessageCommand::set_has_cmdstate() {
  _has_bits_[0] |= 0x00000004u;
}
inline void MessageCommand::clear_has_cmdstate() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void MessageCommand::clear_cmdstate() {
  cmdstate_ = 1;
  clear_has_cmdstate();
}
inline ::Mensajes::MessageCommand_ECmdState MessageCommand::cmdstate() const {
  return static_cast< ::Mensajes::MessageCommand_ECmdState >(cmdstate_);
}
inline void MessageCommand::set_cmdstate(::Mensajes::MessageCommand_ECmdState value) {
  assert(::Mensajes::MessageCommand_ECmdState_IsValid(value));
  set_has_cmdstate();
  cmdstate_ = value;
}

// repeated .Mensajes.InfoDupla argument = 3;
inline int MessageCommand::argument_size() const {
  return argument_.size();
}
inline void MessageCommand::clear_argument() {
  argument_.Clear();
}
inline const ::Mensajes::InfoDupla& MessageCommand::argument(int index) const {
  return argument_.Get(index);
}
inline ::Mensajes::InfoDupla* MessageCommand::mutable_argument(int index) {
  return argument_.Mutable(index);
}
inline ::Mensajes::InfoDupla* MessageCommand::add_argument() {
  return argument_.Add();
}
inline const ::google::protobuf::RepeatedPtrField< ::Mensajes::InfoDupla >&
MessageCommand::argument() const {
  return argument_;
}
inline ::google::protobuf::RepeatedPtrField< ::Mensajes::InfoDupla >*
MessageCommand::mutable_argument() {
  return &argument_;
}

// -------------------------------------------------------------------

// EventInfoDupla

// required uint32 idComponente = 1;
inline bool EventInfoDupla::has_idcomponente() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void EventInfoDupla::set_has_idcomponente() {
  _has_bits_[0] |= 0x00000001u;
}
inline void EventInfoDupla::clear_has_idcomponente() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void EventInfoDupla::clear_idcomponente() {
  idcomponente_ = 0u;
  clear_has_idcomponente();
}
inline ::google::protobuf::uint32 EventInfoDupla::idcomponente() const {
  return idcomponente_;
}
inline void EventInfoDupla::set_idcomponente(::google::protobuf::uint32 value) {
  set_has_idcomponente();
  idcomponente_ = value;
}

// required uint32 idEvento = 2;
inline bool EventInfoDupla::has_idevento() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void EventInfoDupla::set_has_idevento() {
  _has_bits_[0] |= 0x00000002u;
}
inline void EventInfoDupla::clear_has_idevento() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void EventInfoDupla::clear_idevento() {
  idevento_ = 0u;
  clear_has_idevento();
}
inline ::google::protobuf::uint32 EventInfoDupla::idevento() const {
  return idevento_;
}
inline void EventInfoDupla::set_idevento(::google::protobuf::uint32 value) {
  set_has_idevento();
  idevento_ = value;
}

// -------------------------------------------------------------------

// MessageEvent

// required .Mensajes.MessageHeader header = 2;
inline bool MessageEvent::has_header() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void MessageEvent::set_has_header() {
  _has_bits_[0] |= 0x00000001u;
}
inline void MessageEvent::clear_has_header() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void MessageEvent::clear_header() {
  if (header_ != NULL) header_->::Mensajes::MessageHeader::Clear();
  clear_has_header();
}
inline const ::Mensajes::MessageHeader& MessageEvent::header() const {
  return header_ != NULL ? *header_ : *default_instance_->header_;
}
inline ::Mensajes::MessageHeader* MessageEvent::mutable_header() {
  set_has_header();
  if (header_ == NULL) header_ = new ::Mensajes::MessageHeader;
  return header_;
}
inline ::Mensajes::MessageHeader* MessageEvent::release_header() {
  clear_has_header();
  ::Mensajes::MessageHeader* temp = header_;
  header_ = NULL;
  return temp;
}
inline void MessageEvent::set_allocated_header(::Mensajes::MessageHeader* header) {
  delete header_;
  header_ = header;
  if (header) {
    set_has_header();
  } else {
    clear_has_header();
  }
}

// repeated .Mensajes.EventInfoDupla events = 1;
inline int MessageEvent::events_size() const {
  return events_.size();
}
inline void MessageEvent::clear_events() {
  events_.Clear();
}
inline const ::Mensajes::EventInfoDupla& MessageEvent::events(int index) const {
  return events_.Get(index);
}
inline ::Mensajes::EventInfoDupla* MessageEvent::mutable_events(int index) {
  return events_.Mutable(index);
}
inline ::Mensajes::EventInfoDupla* MessageEvent::add_events() {
  return events_.Add();
}
inline const ::google::protobuf::RepeatedPtrField< ::Mensajes::EventInfoDupla >&
MessageEvent::events() const {
  return events_;
}
inline ::google::protobuf::RepeatedPtrField< ::Mensajes::EventInfoDupla >*
MessageEvent::mutable_events() {
  return &events_;
}

// required uint32 eventType = 3;
inline bool MessageEvent::has_eventtype() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void MessageEvent::set_has_eventtype() {
  _has_bits_[0] |= 0x00000004u;
}
inline void MessageEvent::clear_has_eventtype() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void MessageEvent::clear_eventtype() {
  eventtype_ = 0u;
  clear_has_eventtype();
}
inline ::google::protobuf::uint32 MessageEvent::eventtype() const {
  return eventtype_;
}
inline void MessageEvent::set_eventtype(::google::protobuf::uint32 value) {
  set_has_eventtype();
  eventtype_ = value;
}

// -------------------------------------------------------------------

// MessageData

// required .Mensajes.MessageHeader header = 2;
inline bool MessageData::has_header() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void MessageData::set_has_header() {
  _has_bits_[0] |= 0x00000001u;
}
inline void MessageData::clear_has_header() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void MessageData::clear_header() {
  if (header_ != NULL) header_->::Mensajes::MessageHeader::Clear();
  clear_has_header();
}
inline const ::Mensajes::MessageHeader& MessageData::header() const {
  return header_ != NULL ? *header_ : *default_instance_->header_;
}
inline ::Mensajes::MessageHeader* MessageData::mutable_header() {
  set_has_header();
  if (header_ == NULL) header_ = new ::Mensajes::MessageHeader;
  return header_;
}
inline ::Mensajes::MessageHeader* MessageData::release_header() {
  clear_has_header();
  ::Mensajes::MessageHeader* temp = header_;
  header_ = NULL;
  return temp;
}
inline void MessageData::set_allocated_header(::Mensajes::MessageHeader* header) {
  delete header_;
  header_ = header;
  if (header) {
    set_has_header();
  } else {
    clear_has_header();
  }
}

// required uint32 IDData = 3;
inline bool MessageData::has_iddata() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void MessageData::set_has_iddata() {
  _has_bits_[0] |= 0x00000002u;
}
inline void MessageData::clear_has_iddata() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void MessageData::clear_iddata() {
  iddata_ = 0u;
  clear_has_iddata();
}
inline ::google::protobuf::uint32 MessageData::iddata() const {
  return iddata_;
}
inline void MessageData::set_iddata(::google::protobuf::uint32 value) {
  set_has_iddata();
  iddata_ = value;
}

// repeated .Mensajes.InfoDupla metadatos = 1;
inline int MessageData::metadatos_size() const {
  return metadatos_.size();
}
inline void MessageData::clear_metadatos() {
  metadatos_.Clear();
}
inline const ::Mensajes::InfoDupla& MessageData::metadatos(int index) const {
  return metadatos_.Get(index);
}
inline ::Mensajes::InfoDupla* MessageData::mutable_metadatos(int index) {
  return metadatos_.Mutable(index);
}
inline ::Mensajes::InfoDupla* MessageData::add_metadatos() {
  return metadatos_.Add();
}
inline const ::google::protobuf::RepeatedPtrField< ::Mensajes::InfoDupla >&
MessageData::metadatos() const {
  return metadatos_;
}
inline ::google::protobuf::RepeatedPtrField< ::Mensajes::InfoDupla >*
MessageData::mutable_metadatos() {
  return &metadatos_;
}


// @@protoc_insertion_point(namespace_scope)

}  // namespace Mensajes

#ifndef SWIG
namespace google {
namespace protobuf {

template <>
inline const EnumDescriptor* GetEnumDescriptor< ::Mensajes::MessageHeader_MessageType>() {
  return ::Mensajes::MessageHeader_MessageType_descriptor();
}
template <>
inline const EnumDescriptor* GetEnumDescriptor< ::Mensajes::TypeValue_Type>() {
  return ::Mensajes::TypeValue_Type_descriptor();
}
template <>
inline const EnumDescriptor* GetEnumDescriptor< ::Mensajes::MessageCommand_ECmdState>() {
  return ::Mensajes::MessageCommand_ECmdState_descriptor();
}

}  // namespace google
}  // namespace protobuf
#endif  // SWIG

// @@protoc_insertion_point(global_scope)

#endif  // PROTOBUF_definicion_5fmensajeria_2eproto__INCLUDED
